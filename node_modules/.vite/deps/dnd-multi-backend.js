import "./chunk-5WWUZCGV.js";

// node_modules/dnd-multi-backend/dist/index.js
var E = (r) => {
  throw TypeError(r);
};
var P = (r, n, e) => n.has(r) || E("Cannot " + e);
var t = (r, n, e) => (P(r, n, "read from private field"), e ? e.call(r) : n.get(r));
var s = (r, n, e) => n.has(r) ? E("Cannot add the same private member more than once") : n instanceof WeakSet ? n.add(r) : n.set(r, e);
var p = (r, n, e, i) => (P(r, n, "write to private field"), i ? i.call(r, e) : n.set(r, e), e);
var h;
var B = class {
  constructor() {
    s(this, h);
    this.register = (n) => {
      t(this, h).push(n);
    };
    this.unregister = (n) => {
      for (; t(this, h).indexOf(n) !== -1; )
        t(this, h).splice(t(this, h).indexOf(n), 1);
    };
    this.backendChanged = (n) => {
      for (let e of t(this, h))
        e.backendChanged(n);
    };
    p(this, h, []);
  }
};
h = /* @__PURE__ */ new WeakMap();
var c;
var l;
var a;
var d;
var k;
var x;
var T;
var D;
var m;
var v;
var f;
var w = class w2 {
  constructor(n, e, i) {
    s(this, c);
    s(this, l);
    s(this, a);
    s(this, d);
    s(this, k);
    s(this, x, (n2, e2, i2) => {
      if (!i2.backend)
        throw new Error(`You must specify a 'backend' property in your Backend entry: ${JSON.stringify(i2)}`);
      let u = i2.backend(n2, e2, i2.options), o = i2.id, g = !i2.id && u && u.constructor;
      if (g && (o = u.constructor.name), !o)
        throw new Error(`You must specify an 'id' property in your Backend entry: ${JSON.stringify(i2)}
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-5xx`);
      if (g && console.warn(`Deprecation notice: You are using a pipeline which doesn't include backends' 'id'.
        This might be unsupported in the future, please specify 'id' explicitely for every backend.`), t(this, a)[o])
        throw new Error(`You must specify a unique 'id' property in your Backend entry:
        ${JSON.stringify(i2)} (conflicts with: ${JSON.stringify(t(this, a)[o])})`);
      return { id: o, instance: u, preview: i2.preview ?? false, transition: i2.transition, skipDispatchOnTransition: i2.skipDispatchOnTransition ?? false };
    });
    this.setup = () => {
      if (!(typeof window > "u")) {
        if (w2.isSetUp)
          throw new Error("Cannot have two MultiBackends at the same time.");
        w2.isSetUp = true, t(this, T).call(this, window), t(this, a)[t(this, c)].instance.setup();
      }
    };
    this.teardown = () => {
      typeof window > "u" || (w2.isSetUp = false, t(this, D).call(this, window), t(this, a)[t(this, c)].instance.teardown());
    };
    this.connectDragSource = (n2, e2, i2) => t(this, f).call(this, "connectDragSource", n2, e2, i2);
    this.connectDragPreview = (n2, e2, i2) => t(this, f).call(this, "connectDragPreview", n2, e2, i2);
    this.connectDropTarget = (n2, e2, i2) => t(this, f).call(this, "connectDropTarget", n2, e2, i2);
    this.profile = () => t(this, a)[t(this, c)].instance.profile();
    this.previewEnabled = () => t(this, a)[t(this, c)].preview;
    this.previewsList = () => t(this, l);
    this.backendsList = () => t(this, d);
    s(this, T, (n2) => {
      for (let e2 of t(this, d))
        e2.transition && n2.addEventListener(e2.transition.event, t(this, m));
    });
    s(this, D, (n2) => {
      for (let e2 of t(this, d))
        e2.transition && n2.removeEventListener(e2.transition.event, t(this, m));
    });
    s(this, m, (n2) => {
      var _a;
      let e2 = t(this, c);
      if (t(this, d).some((i2) => i2.id !== t(this, c) && i2.transition && i2.transition.check(n2) ? (p(this, c, i2.id), true) : false), t(this, c) !== e2) {
        t(this, a)[e2].instance.teardown();
        for (let [g, b] of Object.entries(t(this, k)))
          b.unsubscribe(), b.unsubscribe = t(this, v).call(this, b.func, ...b.args);
        t(this, l).backendChanged(this);
        let i2 = t(this, a)[t(this, c)];
        if (i2.instance.setup(), i2.skipDispatchOnTransition)
          return;
        let u = n2.constructor, o = new u(n2.type, n2);
        (_a = n2.target) == null ? void 0 : _a.dispatchEvent(o);
      }
    });
    s(this, v, (n2, e2, i2, u) => t(this, a)[t(this, c)].instance[n2](e2, i2, u));
    s(this, f, (n2, e2, i2, u) => {
      let o = `${n2}_${e2}`, g = t(this, v).call(this, n2, e2, i2, u);
      return t(this, k)[o] = { func: n2, args: [e2, i2, u], unsubscribe: g }, () => {
        t(this, k)[o].unsubscribe(), delete t(this, k)[o];
      };
    });
    if (!i || !i.backends || i.backends.length < 1)
      throw new Error(`You must specify at least one Backend, if you are coming from 2.x.x (or don't understand this error)
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-2xx`);
    p(this, l, new B()), p(this, a, {}), p(this, d, []);
    for (let u of i.backends) {
      let o = t(this, x).call(this, n, e, u);
      t(this, a)[o.id] = o, t(this, d).push(o);
    }
    p(this, c, t(this, d)[0].id), p(this, k, {});
  }
};
c = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), w.isSetUp = false;
var M = w;
var S = (r, n, e) => new M(r, n, e);
var y = (r, n) => ({ event: r, check: n });
var L = y("touchstart", (r) => {
  let n = r;
  return n.touches !== null && n.touches !== void 0;
});
var O = y("dragstart", (r) => r.type.indexOf("drag") !== -1 || r.type.indexOf("drop") !== -1);
var C = y("mousedown", (r) => r.type.indexOf("touch") === -1 && r.type.indexOf("mouse") !== -1);
var U = y("pointerdown", (r) => r.pointerType === "mouse");
export {
  O as HTML5DragTransition,
  C as MouseTransition,
  S as MultiBackend,
  U as PointerTransition,
  L as TouchTransition,
  y as createTransition
};
//# sourceMappingURL=dnd-multi-backend.js.map
